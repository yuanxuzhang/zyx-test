/**
 * JDBC 
 * 设计思想：     
 * *************************程序-------驱动管理器------驱动管理器------实际数据库*******************************
 * 根据API编写的程序都可以与驱动管理器进行通信，而驱动管理器则通过驱动程序与实际的数据库通信。
 * 三点：
 * 1）一套“纯”JavaAPI
 * 2）一个驱动管理器
 * 3）一套简单机制，以使的第三方驱动程序可以向驱动管理器注册
 * 驱动器工作原理：
 * 一种是：使用一种与具体数据库无关的协议将数据库请求发给服务器构件，然后该构件再将数据库请求翻译成数据库相关的协议，简化部署，平台相关代码只位于服务器端。
 * 一种是：将JDBC请求直接翻译成数据库相关的协议。
 * 优点：
 * 通过使用标准的SQL语句，甚至是专门的SQL扩展，程序员就可以利用Java语言开发数据库的应用，同时还依旧遵循Java语言的相关约定。
 * 数据库供应商和数据库工具开发商可以提供底层的驱动程序。因此，他们可以优化各自数据库产品的驱动程序。
 * 
 * JDBC配置
 * 1）URL：
 * jdbc：subprotocal：other stuff
 * subprotocal用于选择连接数据库的具体驱动程序,驱动器管理器（DriverManager）遍历所有注册过的驱动器，以便找到一个能够使用数据库URL中指定的子协
 * 议的驱动程序。
 * other stuff参数的格式随所使用的subprotocal不同而不同。
 * 2）驱动程序文件
 * 3）注册驱动器类
 * 一种方式是在Java程序中加载驱动器类   Class.forname()
 * 一种方式是设置jdbc.driver属性      java Djdbc.driver="XXX.XXXX.XXX" 
 * 
 * 执行SQL语句：
 * 1）获取【连接】Connection对象，通过驱动管理器DriverManager.getConnection。
 * *************Connection对象的close方法【立即】关闭当前链接以及释放由它所创建的JDBC资源*****************************
 * 2)创建【语句】Statement对象（不带参数）或PrepareStatement，Connection对象的createStatement方法。
 * executeUodate方法既可以执行DML（INSERT、UPDATE和DELETE）之类的操作，也可以执行DDL（ALERT、CREATE和DROP等）数据定义的操作
 * 他返回SQL命令影响的行数。
 * executeQuery方法执行SELECT查询，返回ResultSet类型对象，可以通过它来每次一行地迭代遍历所有查询结果。
 * ResultSet接口的迭代协议与java.util.Iterator接口稍有不同。对于ResultSet接口，迭代器初始化时被设置在第一行之前的位置，必须调用next
 * 方法将它移动到第一行。另外，他没有hasNext方法，我们需要不断地调用next，直到该方法返回false。
 * 与数组的索引不同，数据库的列序号是从1开始计算的。
 * executeQuery方法执行任意的SQL语句，通常只用于用户提供的交互式查询。可能产生多个结果集和更新计数。
 * **********************Statement对象的close方法用于关闭Statement对象以及他所对应的结果集。*************************
 * ******************************ResultSet对象的close方法【立即】关闭当前的结果集*********************************
 * 
 * 连接、语句和结果集之间关系：
 * 每个连接（Connection）对象都可以创建一个或多个Statment对象。同一个Statement对象可以用于多个不相关的命令和查询。但是，一个Statement
 * 对象最多只能有一个打开的结果集。如果需要执行多个查询操作，且需要同时分析查询结果，那么必须创建多个Statement对象。通常不需要同时处理多个结果集。
 * 如果结果集相互关联，可以使用组合查询，这样就只需要分析一个结果集。【对数据库进行组合查询比使用java程序遍历多个结果集要高效的多】。
 * 使用完ResultSet、Statement和Connection对象后，应立即调用close方法，这些对象都是用了【规模较大的数据结构】和【数据库存储器上的有限资
 * 源】。
 * 如果Statement对象上有一个打开的结果集，那么调用close方法将自动关闭该结果集。同样的，调用Connection类的close方法将关闭该连接上的所有语句。
 * 在Statement是上调用closeOnCompletion方法，在其所有结果集都被关闭后，该语句会立即被自动关闭。
 * 如果连接都是在暂时的，那么无需考虑关闭语句和结果集。只需要close语句放在带try语句中，以便确保最终连接对象不可能继续保持打开状态。
 * 
 * 预备语句（prepare statement）
 * ****每当数据库执行一个查询时，他总是首先通过计算来确定【查询策略】，以便高效地执行查询操作。通过事先准备好查询并多次重用它，我们就可以确保：***
 * *********************************查询所需的准备步骤只被执行一次********************************************
 * PreparedStatement的第一次执行消耗很高，它的性能体现在后边的重复执行，现产生一个优化查询，而后才会执行下旬请求。外加批量执行
 * Statement只有一次请求，适用于不重复执行的情况。
 * 在预备查询语句中，每个宿主变量都用“？”来表示。如果如果存在一个以上的变量，那么在设置变量值时必须注意“？”的位置。在执行预备语句之前，必须使用set
 * 方法将变量绑定到实际的值上，Set方法接受两个参数，参数一指定宿主变量的位置，第二个参数指定赋予宿主变量的值。
 * 如果想要重用已执行过的预备查询语句，那么除非使用set方法或调用clearParameters方法，否则所有宿主变量的绑定都不会改变，即，从一个查询到另一个
 * 查询到另一个查询的过程中，只需要使用setXxx方法重新绑定那些需要改变的变量即可。
 * 字符串拼接缺点：
 * 1）需要格外注意特殊字符串，容易出错。
 * 2）存在注入的风险。
 * 在相关的Connection对象关闭之后，PreparedStatement对象也就变得无效了。不过，许多数据库通常都会自动缓存预备语句。如果相同的查询被预备两
 * 此，数据库通常会直接重用查询策略。因此，无需过多考虑调用prepareStatement的开销。
 * 
 * 相对于大量的迭代多个结果集，使用数据库的复杂语句要比使用Java程序好得多----这是数据库的一个重要优点，一般而言，可以使用SQL解决的问题，就不要使用
 * Java程序。
 */
package com.zyx.jdbc;