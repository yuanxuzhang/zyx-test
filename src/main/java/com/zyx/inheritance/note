1、this和super
this是引用，例如引用对象本身，作为方法的第一个隐式参数，另外还可以调用构造函数。super不是一个对象引用，不能将
super赋值给另一个对象变量，它只是一个指示编辑器调用超类方法的特殊关键字。
子类构造器不能访问父类的私有域，所以必须利用父类的构造器对这部分私有域进行初始化，可以通过super实现对超类的调用。
使用super调用构造器的语句必须是子类构造器的第一条语句。如果子类的构造器没有显示的调用超类的构造器，则将自动调用
超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显示地调用超类的其他构造器
则java编译器将会报错。
2 基本概念
多态（polymorphism）：一个对象变量可以指示多种实际类型的现象。

重载解析（overloading resolution）：编译器将查看调用方法时提供的参数，如果在所有同名方法（同类重载和父类公
有）中存在一个与提供的参数类型完全匹配，就选择这个方法。
【重载解析（确定了方法）后编译器会根据方法的不同生成【静态或动态的方法调用指令】】
静态绑定（static binding）：private方法、static方法、final方法或者构造器，编译器可以准确地知道应该调用
哪个方法。
动态绑定（dynamic binding）：区别于静态绑定，调用的方法依赖于隐式参数的实际类型，并且在运行的时候实现动态绑定，
在运行时能够自动选择调用哪个方法的想象。（final可解除方法的默认动态绑定）
关于final：类中的方法 被声明为final，这样子类就不能覆盖这个方法，同时若类被定义为fianl，则该类不可被继承，它
所包含的方法也都是fianl类型的，【不包括域】。
内联（inline）：动态绑定是会有效率上的影响，有系统开销，如果一个方法没有被覆盖并且很短，编译器就能够对他进行优化
处理，内联就是这个过程，例如getter可直接转化为去取属性。
继承层次（inheritance hierarchy）：由一个公共超类派生出来的所有类的集合。
继承链（ineritance chain）：从某个特定的类到其祖先的路径。
覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法时public，子类方法一定要声明为public。

3、类型转换（classcast）
原因：在暂时忽视对象的实际类型之后，使用对象的全部功能。
时机：将一个子类的引用赋值给一个超类变量，【编译器】是允许的。但将一个超类的引用赋值给一个子类变量，必须进行类型转换，
这样才能够通过运行时的检查，也即是在继承链由上向下的转换必须是显示的。
注意事项：只能在继承层次内进行类型转换。
	        在将超类转换成子类之前，应该使用instanceof进行检查。
特别说明：通过类型转换调整对象的类型并不是一种好的做法，大多数情况下实现多态性的动态绑定能够自动的找到方法，只有在使
用子类中特有的方法时才需要进行类型转换。
	     
4、抽象类（abstractclass）
abstract修饰类，表明这个类是抽象的，不希望被实例化，用在方法上充当着占位符的角色，它们的具体实现在子类中，既然方法 
是抽象，那就不应当被实例化，所以类必须要修饰为abstact不予许实例化。

5、受保护的（protected）
protected一般用到方法上，不用到属性上，违反OOP封装原则。

6、Object
java中，只有基本类型（primitive types）不是对象，例如，数值，字符和布尔类型的值都不是对象。所有的数组类型，都
扩展自Object类。