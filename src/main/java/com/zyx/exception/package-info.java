/**
 * 异常 测试
 * 
 * java语言中，给出了三种处理系统错误的机制：
 * 抛出一个异常
 * 日志-----是一种在程序的整个生命周期都可以使用的【策略性工具】。
 * 使用断言 --一种检测和调试阶段所使用的【战术性工具】。
 * 
 * Java中，异常对象都派生于Throwable类的一个实例。
 * Throwable下一层 包括：Error和Exception。
 * Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户
 * 并尽力使程序安全地终止之外，再也无能为力了。
 * Exception可分解为两支：RuntimeException和其他类型
 * RuntimeException，是由程序错误导致的，包含下面几种情况：
 * 错误的类型转换--------断绝非继承链上的类型转换，以及继承链上的向下转换
 * 数组访问越界---------检测数组下标是否越界
 * 访问空指针 ----------先判断对象是否为空
 * 如果出现RuntimeException异常，那么就一定是程序员的问题-----准则
 * 其他异常包含：
 * 试图在文件尾部后面读取数据
 * 试图打开一个不存在的文件
 * 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。  
 * 
 * 【Java语言规范将派生于Error类或者RuntimeException类的所有异常称为未检查（unchecked）异常，所有的其他异常称为已检查（checked）
 * 异常，编译器将核查是否为所有的已检查提供了异常处理器】
 * 
 * 声明异常：
 * 一个方法必须声明所有可能抛出的已检查异常，而未检查异常要么不可控制（Error），要么就应该避免发生（RuntimeException）。如果方法没有声明
 * 所有可能发生的已检查异常，编译器就会给出一个错误。
 * 
 * 一旦方法抛出了异常，这个方法就不能返回到调用者。也就是说，不必为返回的默认值或错误代码担忧。
 * 
 * 异常捕获：
 * 通常，最好的选择是什么也不做，而是将异常传递给调用者。如果read方法出现了错误，就让read方法的调用者去操心!
 * 编译器严格地执行throws说明符。如果调用一个抛出已检查异常的方法，就必须对他进行处理，或者将它进行传递。
 * 应当捕获知道如何处理的异常，传递不知道怎样处理的异常。
 * 特例：编写一个覆盖超类的方法，而这个方法又没有抛出异常，那么这个方法就必须捕获方法代码中出现的每一个已检查异常。不允许在子类的throws说明符中
 * 【出现超过超类方法所列出的异常类范围】。
 * 
 * 当finally子句包含return语句时，将会出现一种意想不到的结果。假设利用return语句从try语句块中退出。在方法返回前，finally子句的内容
 * 将被执行。如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值。
 * 
 * 带资源的try语句，资源需属于一个实现了AutoCLoseable接口的类。
 * 
 * 使用异常捕获时，同一方法内的异常最好不要细化到多个try-catch块里，最好包在一起，减少代码膨胀。
 */
/**
 * @author Administrator
 *
 */
package com.zyx.exception;