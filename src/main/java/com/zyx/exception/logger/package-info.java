/**
 * 日志测试
 * 
 * 取代System.out.println,日志API优势：
 * 可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易
 * 可以很简单地禁止日志记录的输出，因此，将这些日志代码留在程序中的开销很小
 * 日志记录可以被定向到不同的处理器，用于在控制台中显示，用于存储在文件中等
 * 日志记录可以采用不同的方式格式化，例如，纯文本或XML
 * 应用程序可以使用多个【日志记录器】，它们实用类似包名的这种具有层次结构的名字
 * 在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置
 * 
 * 【日志处理器】   XXXHandler
 * java平台提供的处理器 ConsoleHandler FileHandler（文件处理器） SocketHandler
 * ConsoleHandler它会输出到System.err流中。
 * SocketHandler将记录发送到特定的主机和端口。
 * FileHandler 
 * 常用的文件处理器配置参数：
 * java.util.logger.FileHandler.append 控制处理器应该追加到一个 已经存在的文件尾部；还是应该为每一个运行的程序打开一个新的文件
 * java.util.logger.FileHandler.count 再循环序列中的日志记录数量 （1为不循环）
 * 
 * 【过滤器】
 * 在默认的情况下，过滤器根据日志记录的级别进行过滤。每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤。另外，还可以通过实现Filter接口并定义下列方法来自定义过滤器：
 * boolean isLoggable（LogRecord record）
 * 在这个方法中，可以利用自己喜欢的标准，对日志记录进行分析，返回true表示这些记录应该包含在日志中。
 * 要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用setFilter方法就可以，***同一时刻最多只能有一个过滤器***。
 * 
 * 【格式化器】
 * ConsoleHandler类和FileHandler类可以生成文本和XML格式的日志记录。但是，也可以自定义格式。这需要扩展Formatter类并覆盖下面这个方法：
 * String format（LogRecord record）
 * 可调用setFormatter方法将格式化器安装到处理器中。
 * 
 * 日志记录说明
 * 1.为一个简单的应用程序，选择一个日志记录器，并把日志记录器命名为与主应用程序包一样的名字。
 * 2.默认的日志配置将级别等于或高于INFO级别的所有消息记录到控制台。用户可以覆盖默认的配置文件。
 * 3.现在，可以记录自己想要的内容了。但要牢记：所有级别为INFO、WARNING和SERVERE的消息都将显示到控制台上。因此，最好将对【程序用户】有意义的消息设置为这几个级别，将【程序员】想要的日志记录，设置为FINE
 * 是一个很好的选择。
 * 
 */
package com.zyx.exception.logger;