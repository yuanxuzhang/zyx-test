/**
 * Thread 总结
 * 【并发执行】的进程数目并不是由CPU数目决定的，操作系统将CPU的时间片分配给每一个进程，给人【并行】处理的感觉。
 * 多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务，通常，每一个任务称为一个线程（thread），它是线程控制的简称。可以
 * 同时运行一个以上线程的程序称为多线程程序（multithreaded）。
 * 
 * 多进程和多线程：
 * 本质在于每个进程拥有自己的一整套变量，而线程则共享数据。
 * 1）共享变量使线程之间的通信比进程之间的通信更有效、更容易。
 * 2）在操作系统中，与进程相比，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。
 * 3）共享数据可能存在风险，需要加以控制。
 * 
 * 2、线程中断
 * 线程终止的情况：
 * 1）run方法执行到方法体的最后一条语句，并经由执行return语句返回时。
 * 2）出现了在方法中没有捕获的异常时，线程将终止。
 * 3）已弃用的stop方法。
 * 中断：        中断的线程不应定是要被终止的。
 * interrupt方法可以用来请求终止线程，当一个线程调用interrupt方法时，线程中的【中断状态】将被置空。这是每一个线程都具有的boolean
 * 标志。每个线程都不应该不时地检查这个标志，以判断线程是否被终端。     当一个被阻塞的线程（sleep或wait）上调用interrupt方法时，阻塞调用
 * 将 会InterruptException异常中断
 * 
 * 3、线程的六种状态
 * 1）New（新创建）
 * new操作符创建新线程到start方法调用之前的阶段（程序还没有开始运行线程代码，做一些运行之前定的基础工作）
 * 2）Runnable（可运行）
 * 一旦调用start方法，线程处于runnable状态，一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。
 * 3）Blocked（被阻塞）------------内部锁
 * 4）Waiting（等待）--------------wait
 * 5）Timed waiting（计时等待）
 * 当线程处于被阻塞或等待状态时，它暂时不活动，它不运行任何代码且消耗最少的资源，直到【线程调度器】重新激活它。
 * 当一个线程试图获取一个【内部的对象锁】（非concurrent库中的锁，而该锁被其他线程持有，则线程进入阻塞状态），当所有其他线程释放该锁，并且
 * 线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
 * 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。
 * 在调用Object.wait、Thread.join、concurrnt中的Lock或Condtion时，就会出现等待状态。
 * 6）Terminated（被终止）
 * run方法退出
 * run方法体异常
 */
package com.zyx.thread;