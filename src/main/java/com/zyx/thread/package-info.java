/**
 * Thread 总结
 * 【并发执行】的进程数目并不是由CPU数目决定的，操作系统将CPU的时间片分配给每一个进程，给人【并行】处理的感觉。
 * 多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务，通常，每一个任务称为一个线程（thread），它是线程控制的简称。可以
 * 同时运行一个以上线程的程序称为多线程程序（multithreaded）。
 * 
 * 多进程和多线程：
 * 本质在于每个进程拥有自己的一整套变量，而线程则共享数据。
 * 1）共享变量使线程之间的通信比进程之间的通信更有效、更容易。
 * 2）在操作系统中，与进程相比，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。
 * 3）共享数据可能存在风险，需要加以控制。
 * 
 * 2、线程中断
 * 线程终止的情况：
 * 1）run方法执行到方法体的最后一条语句，并经由执行return语句返回时。
 * 2）出现了在方法中没有捕获的异常时，线程将终止。
 * 3）已弃用的stop方法。
 * 中断：        中断的线程不应定是要被终止的。
 * interrupt方法可以用来请求终止线程，当一个线程调用interrupt方法时，线程中的【中断状态】将被置空。这是每一个线程都具有的boolean
 * 标志。每个线程都不应该不时地检查这个标志，以判断线程是否被终端。     当一个被阻塞的线程（sleep或wait）上调用interrupt方法时，阻塞调用
 * 将 会InterruptException异常中断
 * 
 * 3、线程的六种状态
 * 1）New（新创建）
 * new操作符创建新线程到start方法调用之前的阶段（程序还没有开始运行线程代码，做一些运行之前定的基础工作）
 * 2）Runnable（可运行）
 * 一旦调用start方法，线程处于runnable状态，一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。
 * 3）Blocked（被阻塞）------------内部锁
 * 4）Waiting（等待）--------------wait
 * 5）Timed waiting（计时等待）
 * 当线程处于被阻塞或等待状态时，它暂时不活动，它不运行任何代码且消耗最少的资源，直到【线程调度器】重新激活它。
 * 当一个线程试图获取一个【内部的对象锁】（非concurrent库中的锁，而该锁被其他线程持有，则线程进入阻塞状态），当所有其他线程释放该锁，并且
 * 线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
 * 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。
 * 在调用Object.wait、Thread.join、concurrnt中的Lock或Condtion时，就会出现等待状态。
 * 6）Terminated（被终止）
 * run方法退出
 * run方法体异常
 * 
 * 4、线程属性
 * 每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级
 * setPriority（）--MIN_PRIORTY（1）---NORM_PIORITY（5）---MAX_PRIORITY（10）
 * 每当线程调度器有机会选择新线程时，他首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现
 * 机制时，Java线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。
 * 【不要将程序构建为功能的正确性依赖于优先级，多个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行】
 * yield():导致当前执行线程处于让步状态，如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调控。
 * 守护线程（Daemon）：setDaemon（true）；
 * 守护线程的唯一用途是为其他线程提供服务，当只剩下守护线程时，虚拟机就退出，由于如果只剩下守护线程，就没必要继续运行程序了。
 * 守护线程应该永远不去访问固有资源（文件、数据库等），他会在任何时候甚至在一个操作的中间发生中断。
 * 
 * 异常：线程的run方法不能抛出任何被检测的异常，但是，不被检测的异常会导致线程终止，这种情况下，线程就死亡了。
 * 不需要任何catch子句来处理可以被传播的异常，相反，就在线程死亡之前，异常被传递到一个用于捕获异常的处理器。
 * 可以使用setUncaughtExceptionHandler方法为任何线程安装一个处理器。也可以用Thread类的静态方法setUncaughtExceptionHandler
 * 为所有线程安装一个默认的处理器。替换处理器可以使用日志API发送未捕获异常的报告到日志文件。
 * 如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该相乘的ThreadGroup对象。
 * 处理逻辑：
 * 有父线程组则掉父线程组的uncaughtException方法
 * 否则，Thread.getDefaultExceptionHandler返回非空处理器，则调用。
 * 否则，Throwable时ThreadDeath的一个实例，什么都不做。
 * 否则，线程的名字以及Throwable的栈踪迹被输出到System.err上。
 */
package com.zyx.thread;