/**
 * 类加载器
 * Java编译器会为虚拟机转换源指令。虚拟机代码存储在以.class为扩展名的类文件中，每个类文件都包含某个类或者接口的定义和代码实现。这些类文件必须由一个程序进行解释，
 * 该程序能够将虚拟机的指令翻译成目标机器的机器语言。
 *                      编译器转换                                                                                  虚拟机里的程序
 * Java源文件.java---------------------class文件.class--------------------目标机器指令Command
 * 【虚拟机只加载程序执行时所需的类文件】
 * 以Myprogam.class为例，虚拟机的执行步骤：
 * 1）虚拟机使用加载类文件的机制加载类Myprogram文件（例如，从文件系统）。
 * 2）如果Myprogram类拥有类型为另一个类的【域】，或者是拥有【超类】，那么这些类文件也会被加载。
 * PS：加载某个类所依赖的所有类的过程称为【类的解析】。
 * 3）接着，虚拟机执行Myprogram中的main方法。
 * 4）如果main方法或者main调用的方法要用到更多的类，nm接下来会加载这些类。
 * 
 * 三种类加载器：
 * 1）引导类加载器
 * 负责加载系统类（通常从JAR文件rt.jar中进行加载）。它是虚拟机不可分割的一部分，而且通常是用C语言实现的。
 * 引导类加载器没有对应的ClassLoader对象，例如，String.class.getClassLoader()返回null。
 * 2）扩展类加载器
 * 扩展类加载器用于从jre/lib/ext目录加载“标准的扩展”。可以将JAR文件放入该目录，这样【即使没有任何类路径】，扩展类加载器也可以找到其中的个各类。
 * PS：如果将JAR问价放入jre/lib/ext目录中，并且在它的类中有一个类需要【调用系统类或者扩展类】，那么就会遇到麻烦。【扩展类加载器并不使用类路径】。
 * 3）系统类加载器（亦称：应用类加载器）
 * 用于加载应用类。它是由CLASSPATH环境变量或者-classpath命令行选项设置的类路径中的目录里或者JAR/ZIP文件里查找这些类。
 * 
 * 层次结果：
 * 类加载器有一种父/子关系。除了引导类加载器外，每个类加载器都有一个父类加载器。根据规定，类加载器会为它的父类加载器提供一个机会， 以便加载
 * 任何给定的类，并且只有在其父类加载器加载失败时，他才会记载该给定类。
 * 
 * 类加载器倒置
 * 插件（非ClassPath路径里的）里的类加载或运行时需要解析加载插件JAR里的类，但由于使用Class.forName默认是使用系统类加载器，系统
 * 类加载器并不能找到插件JAR。
 * 解决措施：
 * 1）使用恰当的类加载器，将类加载器作为参数传给Class.forName方法。
 * 2）将恰当的类加载器设置成为当前线程的上下文类加载器。
 * PS:每个线程都有一个对类加载器的引用，称为上下文类加载器。主线程的上下文类加载器是系统类加载器。当新创建线程时，它的上下文类加载器会设置
 * 成为创建该线程的上下文类加载器。因此，不做任何特殊的操作，nm所有线程都将它们的上下文类加载器设置为系统类记载器。
 * 
 * 编写类加载器
 * 可以编写自己的用于特殊目的的类加载器，这使得可以在【向虚拟机传递字节码之前执行定制的检查】
 * 定制类加载器，只需要继承ClassLoader类，然后覆盖findClass（String className）
 * findClass两点逻辑：
 * 1）为来自本地文件系统或者其它来源的类加载其字节码。
 * 2）调用ClassLoader超类的defineClass方法，向虚拟机提供字节码。
 * ClassLoader超类的loaderClass方法用于将类的加载操作委托给其父类加载器去进行，只有当该类尚未加载并且父类加载器也无法加载该类时，才调用findClass方法。
 * 
 * 字节码校验（Code Verifier）
 * 类加载器将新加载的Java平台类的字节码传递给虚拟机时，这些字节码首先要接受校验器的检验，检验器负责检查那些指令【无法执行的】【明显有破坏行的】操作。
 * 除了系统类外，所有的类都要接受的检查，包括但不限于如下：
 * 1）变量要在使用之前进行初始化。
 * 2）方法调用与对象引用类型之间要匹配。
 * 3）访问私有数据和方法的规则没有被破坏。
 * 4）对本地变量的访问都落在运行时堆栈内。
 * 5）运行时堆栈没有溢出。
 * 上述检查中的任何一条没有通过，那么该类就被认为遭到了破坏，并且不予加载。
 * 为什么校验：
 * Java编译器生成的类文件总是可以通过校验的。然而，类文件中使用的字节码格式是有很好的文档记录的，对于具有汇编程序设计经验并且拥有十六进制
 * 编辑器的人来说，要手工创建一个对java虚拟机来说，由合法的但是不安全的指令构成的类文件，是一件非常容易的事情。
 * 校验器总是在防范被故意篡改的类文件，而不仅仅只是检查编译器产生的类文件。
 * 
 * 安全管理器与访问器
 * 一旦某个类被加载到虚拟机中，并由检验器检查过之后，Java平台的第二种安全机制就会启动，这个安全机制是：安全管理器。
 * 安全管理器是一个负责具体操作是否允许执行的【类】。
 * 主要检查如下：
 * 1）创建一个新的类加载器。
 * 2）退出虚拟机。
 * 3）使用反射访问另一个类的成员。
 * 4）访问本地文件。
 * 5）打开socket连接。
 * 6）启动打印作业。
 * 7）访问系统剪贴板。
 * 8）访问AWT事件队列。
 * 9）打开一个顶层窗口。
 * 在运行Java应用程序时，默认的设置是不安装安全管理器的，所有的操作都是允许的。
 */
package com.zyx.security.classloader;