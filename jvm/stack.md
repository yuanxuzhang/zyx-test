每当启动一个新的线程时，Java虚拟机都会为它分配一个Java栈。它是由许多栈帧（stack frame）或者说帧（frame）组成的，**一个栈帧包含一个Java方法调用的状态**。**当线程调用一个Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中**，当该方法返回时，这个栈帧从Java栈中弹出并抛弃。  
某个线程正在执行的方法被称为该线程的*当前方法*，当前方法使用的栈帧称为*当前栈帧*，当前方法所属的类称为*当前类*。在线程执行一个方法时，它会跟踪*当前类*和*当前常量池*。  
每当线程调用一个Java方法时，虚拟机都会在线程的Java栈中压入一个新的帧。而这个新的帧自然成为当前帧。在执行这个方法时，它使用这个帧来存储**参数**、**局部变量**、**中间运算结果**等数据。  
### 栈的同步问题  
Java栈上的所有数据都是此线程私有的。任何线程都不能访问另一个线程的栈数据，因此不必考虑多线程情况下*栈数据*的访问同步问题。**当一个线程调用一个方法时，方法的局部变量保存在调用线程Java栈中。只有一个线程能访问这些局部变量，即调用方法的线程**。  
### 栈帧  
栈帧由三部分组成：局部变量区，操作数栈和帧数据区。局部变量区和操作数栈的大小要视对应的方法而定，它们是按字长计算的。*编译器在编译时就确定了这些值并存储在class文件中*。而帧数据区的大小依赖于具体的实现。  
**局部变量和操作数栈的大小在编译时计算出来，并放置到Class文件中去，然后虚拟机就能够了解到方法的栈帧需要多少内存**，当虚拟机调用一个Java方法时，它从对应的类信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入Java栈中。   
#### 局部变量区  
形式：以字长为单位、从0开始计数的**数组**，字节码指令从0开始的索引来使用其中的数据。  
内容：包含对应方法的参数和局部变量。
* 编译器首先按*声明的顺序*把这些**参数**放入局部变量数组。  
* 对于局部变量，它可以任意决定顺序  
PS：Java中对象都是按照引用传递，并且都存储在堆中，所以栈中不对存储对象，栈中直接能是对象引用。  
#### 操作数栈  
形式：操作数栈也是被组织成一个以字长为单位的**数组**，他不是通过索引来访问，而是使用标准的栈操作。  
内容：指令的操作数  
#### 帧数据区  
目的：支持常量池解析、正常方法的返回以及异常派发等。  
* 当虚拟机要执行某个需要用到常量池数据的指令时，他会通过帧数据区中指向常量池的指针来访问它。  
* *正常结束*（return），虚拟机必须恢复发起*调用的方法*的栈帧，包括PC寄存器执行发起调用的方法中的指令（紧跟着调用完成方法的指令的下一个指令），**假如方法有返回值，虚拟机必须将它压入到发起调用的方法的操作数栈中**。*异常结束*保存了此方法异常表的引用。
* 方法抛出异常时，虚拟机根据帧数据区对应的异常表来决定如何处理。如果在异常表中找到了匹配的catch子句，就会把控制权交给catch子句内的代码；如果没有发现，**方法**会立即异常终止，然后虚拟机使用帧数据区的信息恢复发起调用的方法的帧，然后在**发起调用方法**的上下文中重新抛出同样的异常。  


