## 垃圾回收器  
两个任务  
* 内存回收 当一个对象不再被程序所引用时，它所使用的对空间可以被回收，以便被后续的新对象使用。两部：**断定不被引用的对象** **回收对象**。在释放不再被引用的对象过程中，垃圾收集器运行将要被释放对象的终结方法（finalizer）。  
* 处理堆碎片 堆内闲置的空间介于活动的对象之间。  
### 垃圾收集算法  
#### 检测垃圾对象  
通过建立一个根对象的**集合**并检测从这些根对象开始的可触及性来实现。根对象总是可以访问的，从这些根对象开始，任何可以被触及的对象都被认为是“活动”的对象。无法触及的对象被认为是垃圾，因为它们不再影响程序的未来执行。  
根对象包含：  
* 局部变量中的对象引用和栈帧的操作数栈（以及类变量中的对象引用）  
* 被加载的类的常量池中的对象引用，比如字符串。常量池可能指向保存在堆中的字符串，比如类名字，超类的名字，接口的名字，字段名等。  
* 传递到本地方法中的、没有被本地方法“释放”的引用对象。  
* Java虚拟机运行时数据器中从垃圾收集器的堆中分配的部分。 

区分活动对象和垃圾对象的两个基本方法是**引用计数**和**跟踪**  
* 引用计数 通过为堆中的每个对象保存一个计数来区分活动对象和垃圾对象。这个计数记录了对那个对象的引用次数。  
* 跟踪     追踪从根节点开始的引用图。在追踪中遇到的对象以某种方式打上标记，当追踪结束时，没有打上标记的对象就被判定是不可触及的，可以被当做垃圾收集。

#### 引用计数  
早期策略  堆中每一个对象都有一个引用计数。当一个对象被创建了，并且指向该对象的引用被分配给一个变量，这个对象得引用计数被置为1，当任何其他变量被赋值为这个对象的引用时，计数加1.当一个对象的引用超过了生存期或者被设置了一个新的值时，对象的引用计数减1。任何引用计数为0的对象可以被当作垃圾收集。**当一个对象被垃圾收集的时候，它引用的任何对象计数值减1，一个对象被垃圾收集后可能导致后续其他对象的垃圾收集行为**。  
* 优点 很快地执行，交织在程序的运行之中，对于程序不能被长时间打断的实时环境很有利。  
* 缺点 无法检测循环引用；每次引用计数的增加或者减少都带来额外开销。  
#### 跟踪收集器  
追踪从根节点开始的对象引用图。在追踪过程中遇到的对象以某种方式打上标记。总的来说，要么**在对象本身设置标记**，要么**用一个独立的位图来设置标记**。当追踪结束时，未被标记的对象就知道是无法触及的，从而可以被收集。  
**标记并清除**是最基本的追踪算法。分为两个阶段：  
1. 标记阶段，垃圾收集器遍历**引用树**，标记每一个遇到的对象。  
2.  清除阶段，未被标记的对象被释放了，使用的内存被返回到正在执行的程序（）**清除步骤必须包含对象的终结**（）  
#### 压缩收集器  
把活动的对象越过空闲区滑动到堆的**一端**，在这个过程中，堆的**另一端**出现一个大的连续空闲区，所有被移动的对象的引用也被更新，指向新的位置。  
#### 拷贝收集器  
把所有的活动对象移动到一个新的区域。拷贝的过程中，它们被紧挨着布置，所以可以消除原本它们在旧区域的空隙。原有区域被认为是空闲区。优点：**对象可以从根对象开始的遍历过程中随着发现而拷贝，不再有标记和清除区分**。  
算法实现有**停止并拷贝**  
1. 堆被分为两个区域，任何时候都是用其中的一个区域。对象在同一个区域中分配，直到这个区域被耗尽。  
2. **此时程序被终止**  
3. 堆被遍历，遍历时遇到的活动对象被**拷贝**到另一个区域。  
4. 停止和拷贝过程结束，程序恢复执行。
缺点：任何时候只能使用堆的一半大小。  
#### 垃圾对象内存返还程序  

